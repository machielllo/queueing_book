* Queueing process in discrete time
story about psychiatrist
blocking is most effective
chop up time in periods
- a_k = # jobs arriving in p k
- c_k = capacity (max # jobs served in p k)
- d_k = # jobs departing in p k
- L_k = system length, # jobs at the end of period k
In this system no jobs are in service (ie L is also jobs in queue)
Jobs arrive at start or end of period, so can be served in or not in period.
Depend on context, the first underestimates the second overestimates.

Recursions and control rules.

** Exercises 2.1

2.1.1

#+begin_src python :results output
    a = [0, 5, 4, 9]
    c = len(a)*[7]
    L = [0]*(len(a) + 1)
    L[0] = 8

    for k in range(1, len(a)):
        d = min(L[k-1], c[k])
        L[k] = L[k-1] + a[k] - d

    print(f'Queue at end of period 3, when arrivals are at the end of the period: {L[3]}')
  
    for k in range(1, len(a)):
        d = min(L[k-1] + a[k], c[k])
        L[k] = L[k-1] + a[k] - d

    print(f'Queue at end of period 3, when arrivals are at the start of the period: {L[3]}')
#+end_src

#+RESULTS:
: Queue at end of period 3, when arrivals are not served in the same period: 9
: Queue at end of period 3, when arrivals are served in the same period: 5

2.1.2
prove by splitting up in both cases
#+begin_src python :results output
  a = [0, 5, 4, 9]
  c = len(a)*[7]
  L = [0]*(len(a) + 1)
  L[0] = 8

  for k in range(1, len(a)):
     L[k] = max(L[k-1] - c[k], 0) + a[k]

  print(f'Queue at end of period 3, when arrivals are at the end of the period: {L[3]}')

  for k in range(1, len(a)):
      L[k] = max(L[k-1] + a[k] - c[k], 0)

  print(f'Queue at end of period 3, when arrivals are at the start of the period: {L[3]}')
#+end_src

#+RESULTS:
: Queue at end of period 3, when arrivals are at the end of the period: 9
: Queue at end of period 3, when arrivals are at the start of the period: 5

2.1.3
#+begin_src python :results output
  import numpy as np
  n = 100
  a = np.random.randint(3,7, n)
  c = [4]*len(a)
  L = np.zeros_like(a)
  L[0] = 8
  K = 16
  lost = np.zeros_like(a)

  for k in range(1, len(L)):
      d = min(L[k-1], c[k])
      L[k] = min(K, L[k-1] + a[k] - d)
      lost[k] = max(0, L[k-1] + a[k] - d - K)

  for k in range(1, len(L)):
      d = min(L[k-1], c[k])
      al = min(a[k], K - L[k-1] + d)
      L[k] = L[k-1] + al - d
      lost[k] = a[k] - al

  print(f'fraction of lost customers: {lost.sum()/a.sum()}')
#+end_src

#+RESULTS:
: fraction of lost customers: 0.10154525386313466

2.1.4
note that a fraction p+p^2+p^3+... of the "departures" is added to the input of the server,
so the service rate needs to be at least 1/q times the arrival rate.

#+begin_src python :results file
  import numpy as np
  import matplotlib.pyplot as plt
  n = 20000

  a = [80]*n
  c = [100]*n

  L = np.zeros_like(a)
  L[0] = 0
  p = 0.2
  f = 0

  for k in range(1, len(L)):
      m = min(L[k-1], c[k])
      d = np.random.binomial(m, 1-p)
      L[k] = L[k-1] + a[k] - d

  plt.clf()
  plt.plot(L, label='failure')

  for k in range(1, len(L)):
      d = min(L[k-1], c[k])
      L[k] = L[k-1] + a[k] - d

  plt.plot(L, label='nofailure')
  plt.legend()
  plt.savefig('Serverwithfailure.png')
  return 'Serverwithfailure.png'
#+end_src

#+RESULTS:
[[file:Serverwithfailure.png]]

2.1.5
#+begin_src python :results file
  import numpy as np
  import matplotlib.pyplot as plt
  n = 200

  a = np.random.poisson(80, n)
  c = [100]*n

  L = np.zeros_like(a)
  L[0] = 100
  p = 0.2
  f = 0

  for k in range(1, len(L)):
      Sn = min(L[k-1], c[k]) - int((f+1)/2)
      df = np.random.binomial(f, 1-p)
      dn = np.random.binomial(Sn, 1-p)
      f = f - df + Sn - dn
      L[k] = L[k-1] + a[k] - df - dn

  plt.clf()
  plt.plot(L, label='failure')


  for k in range(1, len(L)):
      d = min(L[k-1], c[k])
      L[k] = L[k-1] + a[k] - d

  plt.plot(L, label='nofailure')
  plt.legend()
  plt.savefig('halffailure.png')
  return 'halffailure.png'
#+end_src

#+RESULTS:
[[file:halffailure.png]]

2.1.6
#+begin_src python :results output
  import numpy as np
  import matplotlib.pyplot as plt
  T = 100
  a = np.random.poisson(4,T)
  #the capacity is set at the start of the period?
  #Let's assume there is a maximum of 5
  c = 5*np.ones_like(a)
  L = np.zeros_like(a)
  C = np.zeros_like(a)
  b = 1
  h = 1
  for k in range(1, len(L)):
      d = min(L[k-1] + a[k], c[k])
      L[k] = L[k-1] + a[k] - d
      C[k] = d*b + h*L[k]

  print(f'Total costs = {C.sum()}')
  plt.plot(L, label='Systemlength')
  plt.savefig('syslen.png')
  #return 'syslen.png'
#+end_src

#+RESULTS:
: Total costs = 513

2.1.7
I changed it to the case where there is only going to be folks served if
the queue + new arrivals can be served.
#+begin_src python :results file
    import numpy as np
    import matplotlib.pyplot as plt
    T = 100
    a = np.random.poisson(14,T)
    #the capacity is set at the start of the period?
    #Let's assume there is a maximum of 5
    c = 15*np.ones_like(a)
    L = np.zeros_like(a)
    N = 15

    for k in range(1, len(L)):
        if L[k-1] + a[k] >= N:
            d = c[k]
        else: d = 0
        L[k] = L[k-1] + a[k] - d

    plt.clf()
    plt.plot(L, label='with treshold')

    for k in range(1, len(L)):
        d = min(L[k-1] + a[k], c[k])
        L[k] = L[k-1] + a[k] - d

    plt.plot(L, label='no treshold')
    plt.legend(loc="upper right")
    plt.savefig('Treshold.png')
    return 'Treshold.png'
#+end_src

#+RESULTS:
[[file:Treshold.png]]

2.1.8
#+begin_src python :results output
  import numpy as np

  T = 100
  a = np.random.poisson(14,T)
  #the capacity is set at the start of the period?
  #Let's assume there is a maximum of 15
  c = 15*np.ones_like(a)     #service capacity
  L = np.zeros_like(a)       
  C = np.zeros_like(a)       #Cost per period
  #prices and parameters
  N = 20
  K = 5
  b = 2
  h = 1
  ON = 1
  OFF = 0
  STATE = OFF                 #The machine starts off, as L[0] = 0
  count = 0                   #Number of times the machine is turned on

  for k in range(1, len(L)):
      d = min(L[k-1] + a[k], c[k])
      L[k] = L[k-1] + a[k] - d*STATE
      C[k] = h*L[k] + b*STATE
      if L[k] >= N:
          STATE = ON
          count += 1
      if L[k] == 0:
          STATE = OFF

  print(f'Total costs: {sum(C) + b*count}')
#+end_src

#+RESULTS:
: Total costs: 2113

2.1.9
Lk = ak
2.1.10
given Lk
2.1.11
#+begin_src python :results file
  import numpy as np
  import matplotlib.pyplot as plt

  num = 100
  a1 = np.random.poisson(5,num)
  a2 = np.random.poisson(5,num)
  c = np.random.poisson(11, num)
  L1 = np.zeros(num,dtype=int)
  L2 = np.zeros(num,dtype=int)
  
  for k in range(1,len(L1)):
      d1 = min(L1[k-1], c[k])
      d2 = min(L2[k-1], c[k] - d1)
      L1[k] = L1[k-1] + a1[k] - d1
      L2[k] = L2[k-1] + a2[k] - d2

  plt.plot(L1, label='priority')
  plt.plot(L2, label='derderangs')
  plt.legend()
  plt.savefig('priorityqueue.png')
  return 'priorityqueue.png'
#+end_src

#+RESULTS:
[[file:priorityqueue.png]]

2.1.12
#+begin_src python :results file
  import numpy as np
  import matplotlib.pyplot as plt

  num = 100
  a1 = np.random.poisson(5,num)
  a2 = np.random.poisson(5,num)
  c = np.random.poisson(11, num)
  L1 = np.zeros(num,dtype=int)
  L2 = np.zeros(num,dtype=int)
  L1[0] = 12
  L2[0] = 5

  for k in range(1,len(L1)):
      ratio = L1[k-1]/(L1[k-1]+L2[k-1])
      d1 = min(L1[k-1], int(ratio*c[k]))
      d2 = min(L2[k-1], c[k] - d1)
      L1[k] = L1[k-1] + a1[k] - d1
      L2[k] = L2[k-1] + a2[k] - d2

  plt.plot(L1, label='first')
  plt.plot(L2, label='second')
  plt.legend()
  plt.savefig('proportionalqueue.png')
  return 'proportionalqueue.png'
#+end_src

#+RESULTS:
[[file:proportionalqueue.png]]

2.1.15
#+begin_src python :results output
  import numpy as np
  from scipy.stats import poisson
  import matplotlib.pyplot as plt


  
#+end_src


2.1.17
two stations that send their products to station C
#+begin_src python :results output
  import numpy as np
  import scipy.stats as sc
  import matplotlib.pyplot as plt

  num = 100
  p = 1/12
  aA = sc.geom.rvs(p, size=num)
  aB = sc.geom.rvs(p, size=num)
  sA = sc.poisson.rvs(1.1/p,size=num)
  sB = sc.poisson.rvs(1.1/p,size=num)
  sC = sc.poisson.rvs(2/p,size=num)

  # the variance of the arrivals of A and B is way higher than
  # the service rate is.
  # is geometric realistic? basically we are saying every period is until a succes and the arrivals are failures. 
  LA = np.zeros(num)
  LB = np.zeros(num)
  LC = np.zeros(num)

  LA[0] = 19
  LB[0] = 19
  LC[0] = 19
  for k in range(1, num):
      dA = min(LA[k-1] + aA[k], sA[k])
      dB = min(LB[k-1] + aB[k], sB[k])
      aC = dA + dB                       #arrivals for A and B are served
      dC = min(LC[k-1] + aC, sC[k])      #in the same period, so arrive
      LA[k] = LA[k-1] + aA[k] - dA
      LB[k] = LB[k-1] + aB[k] - dB
      LC[k] = LC[k-1] + aC - dC

  plt.plot(LA, label='A')
  plt.plot(LB, label='B')
  plt.plot(LC, label='C')
  plt.legend()
  plt.savefig("mergingstreams.png")
  #  return 'mergingstreams.png'
#+end_src

#+RESULTS:
: 63
: 26

2.1.18
paint mixing machine for downstream two machines own queue
#+begin_src python :results file
  import numpy as np
  import scipy.stats as sc
  import matplotlib.pyplot as plt

  num = 100
  p = 1/12
  aA = sc.poisson.rvs(1/p, size=num)
  aB = sc.poisson.rvs(1/p, size=num)
  sA = sc.poisson.rvs(1.1/p,size=num)
  sB = sc.poisson.rvs(1.1/p,size=num)
  sC = sc.poisson.rvs(2/p,size=num)

  # the variance of the arrivals of A and B is way higher than
  # the service rate is.
  # is geometric realistic? basically we are saying every period is until a succes and the arrivals are failures. 
  LA = np.zeros(num)
  LB = np.zeros(num)
  LC = np.zeros(num)

  LA[0] = 19
  LB[0] = 19
  LC[0] = 19
  for k in range(1, num):
      dA = min(LA[k-1] + aA[k], sA[k])
      dB = min(LB[k-1] + aB[k], sB[k])
      aC = dA + dB                       #arrivals for A and B are served
      dC = min(LC[k-1] + aC, sC[k])      #in the same period, so arrive
      LA[k] = LA[k-1] + aA[k] - dA
      LB[k] = LB[k-1] + aB[k] - dB
      LC[k] = LC[k-1] + aC - dC

  plt.plot(LA, label='A')
  plt.plot(LB, label='B')
  plt.plot(LC, label='C')
  plt.legend()
  plt.savefig("mergingstreams.png")
  #  return 'mergingstreams.png'
#+end_src

#+RESULTS:
[[file:None]]

2.1.19
#+begin_src python :results file
  import numpy as np
  import scipy.stats as sc
  import matplotlib.pyplot as plt

  num = 50
  p = 4
  aA = sc.poisson.rvs(p, size=num)
  aB = sc.poisson.rvs(p, size=num)
  sA = sc.poisson.rvs(2.2*p,size=num)

  # the variance of the arrivals of A and B is way higher than
  # the service rate is.
  # is geometric realistic? basically we are saying every period is until a succes and the arrivals are failures. 
  LA = np.zeros(num)
  LB = np.zeros(num)
  atB = 0
  LA[0] = 12
  LB[0] = 19
  setup = 1
  count = 1 
  for k in range(1, num):
      dA = min(LA[k-1] + aA[k], sA[k]) * (1 - atB) * setup
      dB = min(LB[k-1] + aB[k], sA[k]) * atB * setup
      LA[k] = LA[k-1] + aA[k] - dA
      LB[k] = LB[k-1] + aB[k] - dB
      if atB*LB[k] + (1-atB)*LA[k] == 0:
          atB = atB**atB - atB
          setup = 0
          count = 0
      elif count >= 6:
          setup = 1 
      count += 1
  plt.clf()
  plt.plot(LA, label='A')
  plt.plot(LB, label='B')
  plt.legend()
  plt.savefig('queuewithswitchtimes.jpg')
  return 'queuewithswitchtimes.jpg'
#+end_src

#+RESULTS:
[[file:queuewithswitchtimes.jpg]]
